# === @begin: Headers Configuration ===
# By default, it's an empty string, but we still must define it otherwise `configure_file` will fail.
# In theory, one who builds this package may define that to unique value to be used in a `nccl` version string.
# We, however, don't do that in Eugo environment and keep it mostly for compatability with original Makefile builds.
set(NCCL_SUFFIX "")

# Define a directory where we will place the configured (generated by filling placeholders in `nccl.h.in` file) `nccl.h` header file.
# And other headers that may be generated in the future.
set(CONFIGURED_HEADERS_DIR "${CMAKE_CURRENT_BINARY_DIR}/include")
file(MAKE_DIRECTORY "${CONFIGURED_HEADERS_DIR}")

configure_file(
    ${CMAKE_CURRENT_SOURCE_DIR}/nccl.h.in
    ${CONFIGURED_HEADERS_DIR}/nccl.h
)
# NOTE: this is the NVIDIA_ORIGINAL and just for documentation purposes.
# We can't place this in `nccl.h.in` file b/c it causes errors, so leaving it here for reference
# #define NCCL_MAJOR ${nccl:Major}
# #define NCCL_MINOR ${nccl:Minor}
# #define NCCL_PATCH ${nccl:Patch}
# #define NCCL_SUFFIX "${nccl:Suffix}"
#
# #define NCCL_VERSION_CODE ${nccl:Version}
# === @end: Headers Configuration ===


# === @begin: nccl_header target ===
# @EUGO_CHANGE: Upstream defines this as a dependency ordering target so that other targets
# (nccl_device, llvm_ir) can depend on the configured nccl.h being available.
# Root CMakeLists.txt references: add_dependencies(llvm_ir nccl_header)
# src/device/CMakeLists.txt references: add_dependencies(nccl_device nccl_header)
add_custom_target(nccl_header DEPENDS ${CONFIGURED_HEADERS_DIR}/nccl.h)
# === @end: nccl_header target ===


# === @begin: generate_git_version ===
# @EUGO_CHANGE: New upstream feature (v2.29.x). Generates git_version.h at build time
# which is #included by misc/git_version.cc. The script only rewrites the file if content changed.
# We output to CONFIGURED_HEADERS_DIR (build/src/include/) which is already on the include path,
# rather than upstream's ${CMAKE_BINARY_DIR}/include which would need a separate include dir.
set(GIT_VERSION_FILE "${CONFIGURED_HEADERS_DIR}/git_version.h")
add_custom_target(generate_git_version ALL
    COMMAND ${Python3_EXECUTABLE} ${CMAKE_SOURCE_DIR}/src/misc/generate_git_version.py ${GIT_VERSION_FILE}
    COMMENT "Checking git version"
    BYPRODUCTS ${GIT_VERSION_FILE}
)
# === @end: generate_git_version ===


# === @begin: device/ ===
add_subdirectory(device)
# === @end: device/ ===


# === @begin: DOCA GPUNetIO Header Copying ===
# @EUGO_CHANGE: The DOCA headers live under doca-gpunetio (with a hyphen), but C++ includes
# reference doca_gpunetio (with an underscore). We copy them to the build directory at the
# expected underscore path. Upstream handles this via add_subdirectory chain
# (transport → net_ib → gdaki); we inline the logic here for our flat-list architecture.
#
# Include chain: gin_device_api.h → gin_gdaki.h → "doca_gpunetio/doca_gpunetio_device.h"
#   which includes 5 .cuh device headers. This chain is only compiled by device code
#   (.cu files generated by generate.py in the nccl_colldevice target).

set(DOCA_HOME ${CMAKE_CURRENT_SOURCE_DIR}/transport/net_ib/gdaki/doca-gpunetio)
set(DOCA_INCLUDE_SOURCE_DIR ${DOCA_HOME}/include)
set(DOCA_INCLUDE_DEST_DIR ${CMAKE_BINARY_DIR}/include/nccl_device/gin/gdaki/doca_gpunetio)

# Copy top-level device header
file(GLOB DOCA_HEADER_TOP ${DOCA_INCLUDE_SOURCE_DIR}/doca_gpunetio_device.h)
foreach(HEADER_FILE ${DOCA_HEADER_TOP})
    get_filename_component(HEADER_NAME ${HEADER_FILE} NAME)
    configure_file(${HEADER_FILE} ${DOCA_INCLUDE_DEST_DIR}/${HEADER_NAME} COPYONLY)
    list(APPEND DEVICE_DOCA_HEADERS ${DOCA_INCLUDE_DEST_DIR}/${HEADER_NAME})
endforeach()

# Copy common/ headers (.h)
file(GLOB DOCA_HEADER_COMMON ${DOCA_INCLUDE_SOURCE_DIR}/common/*.h)
foreach(HEADER_FILE ${DOCA_HEADER_COMMON})
    get_filename_component(HEADER_NAME ${HEADER_FILE} NAME)
    configure_file(${HEADER_FILE} ${DOCA_INCLUDE_DEST_DIR}/common/${HEADER_NAME} COPYONLY)
    list(APPEND DEVICE_DOCA_HEADERS ${DOCA_INCLUDE_DEST_DIR}/common/${HEADER_NAME})
endforeach()

# Copy device/ headers (.cuh) — these contain CUDA device code (__device__, PTX asm, etc.)
# They are only compiled via the device header chain into generated .cu files.
file(GLOB DOCA_HEADER_DEVICE ${DOCA_INCLUDE_SOURCE_DIR}/device/*.cuh)
foreach(HEADER_FILE ${DOCA_HEADER_DEVICE})
    get_filename_component(HEADER_NAME ${HEADER_FILE} NAME)
    configure_file(${HEADER_FILE} ${DOCA_INCLUDE_DEST_DIR}/device/${HEADER_NAME} COPYONLY)
    list(APPEND DEVICE_DOCA_HEADERS ${DOCA_INCLUDE_DEST_DIR}/device/${HEADER_NAME})
endforeach()
# === @end: DOCA GPUNetIO Header Copying ===


# === @begin: `libnccl` library ===
set(NCCL_SRC_FILES
    # === @begin: ./ (`@/src/CMakeLists.txt`) ===
    allocator.cc
    bootstrap.cc
    ce_coll.cc
    channel.cc
    collectives.cc
    debug.cc
    dev_runtime.cc
    # enhcompat.cc # only used with `libcudart_static.a` and intended for its old versions support. Current implementation looks extremely dangerous as it overrides the `cudart` symbols w/ its "crashing" stubs.
    enqueue.cc
    group.cc
    init.cc
    init_nvtx.cc
    mnnvl.cc
    proxy.cc
    sym_kernels.cc
    transport.cc
    # === @end: ./ (`@/src/CMakeLists.txt`) ===


    # === @begin: ./misc/ (`@/src/CMakeLists.txt`) ===
    misc/argcheck.cc
    misc/cudawrap.cc
    misc/gdrwrap.cc
    misc/ibvsymbols.cc
    misc/ibvwrap.cc
    misc/ipcsocket.cc
    misc/mlx5dvsymbols.cc
    misc/mlx5dvwrap.cc
    misc/nvmlwrap.cc
    misc/param.cc
    misc/shmutils.cc
    misc/socket.cc
    misc/strongstream.cc
    misc/utils.cc
    misc/git_version.cc
    # === @end: ./misc/ (`@/src/CMakeLists.txt`) ===


    # === @begin: ./plugin/ ===
    # === @@begin: `@/src/plugin/CMakeLists.txt` ===
    plugin/net.cc
    plugin/plugin_open.cc
    plugin/profiler.cc
    plugin/tuner.cc
    plugin/env.cc
    # === @@end: `@/src/plugin/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/net/CMakeLists.txt` ===
    plugin/net/net_v6.cc
    plugin/net/net_v7.cc
    plugin/net/net_v8.cc
    plugin/net/net_v9.cc
    plugin/net/net_v10.cc
    plugin/net/net_v11.cc
    # === @@end: `@/src/plugin/net/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/profiler/CMakeLists.txt` ===
    plugin/profiler/profiler_v1.cc
    plugin/profiler/profiler_v2.cc
    plugin/profiler/profiler_v3.cc
    plugin/profiler/profiler_v4.cc
    plugin/profiler/profiler_v5.cc
    plugin/profiler/profiler_v6.cc
    # === @@end: `@/src/plugin/profiler/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/tuner/CMakeLists.txt` ===
    plugin/tuner/tuner_v2.cc
    plugin/tuner/tuner_v3.cc
    plugin/tuner/tuner_v4.cc
    plugin/tuner/tuner_v5.cc
    # === @@end: `@/src/plugin/tuner/CMakeLists.txt` ===

    # === @@begin: `@/src/plugin/env/CMakeLists.txt` ===
    plugin/env/env_v1.cc
    # === @@end: `@/src/plugin/env/CMakeLists.txt` ===
    # === @end: ./plugin/ ===


    # === @begin: ./transport/ (`@/src/transport/CMakeLists.txt`) ===
    transport/coll_net.cc
    transport/generic.cc
    transport/net.cc
    transport/net_socket.cc
    transport/nvls.cc
    transport/p2p.cc
    transport/profiler.cc
    transport/shm.cc

    # === @@begin: ./transport/net_ib/ (`@/src/transport/net_ib/CMakeLists.txt`) ===
    # @EUGO_CHANGE: Upstream v2.29.x split the old transport/net_ib.cc into 7 files.
    transport/net_ib/common.cc
    transport/net_ib/connect.cc
    transport/net_ib/gdr.cc
    transport/net_ib/gin.cc
    transport/net_ib/init.cc
    transport/net_ib/p2p.cc
    transport/net_ib/reg.cc
    # === @@end: ./transport/net_ib/ (`@/src/transport/net_ib/CMakeLists.txt`) ===

    # === @@begin: ./transport/net_ib/gdaki/ (`@/src/transport/net_ib/gdaki/CMakeLists.txt`) ===
    transport/net_ib/gdaki/gin_host_gdaki.cc
    # === @@end: ./transport/net_ib/gdaki/ (`@/src/transport/net_ib/gdaki/CMakeLists.txt`) ===

    # === @@begin: ./transport/net_ib/gdaki/doca-gpunetio/src/ ===
    # @EUGO_CHANGE: All 13 .cpp files are pure host code (IB verbs, mlx5dv, dlopen wrappers).
    # They do NOT include .cuh headers and do NOT contain __device__/__global__ qualifiers.
    # They correctly remain .cpp — do NOT rename to .cu.
    transport/net_ib/gdaki/doca-gpunetio/src/doca_gpunetio.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_gpunetio_gdrcopy.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_gpunetio_high_level.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_gpunetio_log.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_cq.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_cuda_wrapper.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_device_attr.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_ibv_wrapper.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_mlx5dv_wrapper.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_qp.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_srq.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_uar.cpp
    transport/net_ib/gdaki/doca-gpunetio/src/doca_verbs_umem.cpp
    # === @@end: ./transport/net_ib/gdaki/doca-gpunetio/src/ ===
    # === @end: ./transport/ (`@/src/transport/CMakeLists.txt`) ===


    # === @begin: ./graph/ ===
    # === @begin: Private Header Files ===
    # @TODO: probably we should refactor that into `target_include_directories()`
    # Upstream implementation doesn't include these boys explicitely, but it works as they are stored in the same folder, but we want to be explicit and not rely on an accident in our build.
    graph/rings.h
    graph/topo.h
    graph/xml.h
    # === @@end: Private Header Files ===

    # === @@begin: Source Files (`@/src/graph/CMakeLists.txt`) ===
    graph/connect.cc
    graph/paths.cc
    graph/rings.cc
    graph/search.cc
    graph/topo.cc
    graph/trees.cc
    graph/tuning.cc
    graph/xml.cc
    # === @@end: Source Files (`@/src/graph/CMakeLists.txt`) ===
    # === @end: ./graph/ ===


    # === @begin: ./register/ (`@/src/register/CMakeLists.txt`) ===
    register/coll_reg.cc
    register/register.cc
    register/sendrecv_reg.cc
    # === @end: ./register/ (`@/src/register/CMakeLists.txt`) ===


    # === @begin: ./ras (`@/src/ras/CMakeLists.txt`) ===
    # In the same directory they store both files for the `libnccl` portion of `ras` symbols and source for `ncclras` executable.
    # In our original version, we accidentally used them all to build `ncclras` that led to undefined symbol errors at runtime.
    ras/client_support.cc
    ras/collectives.cc
    ras/peers.cc
    ras/ras.cc
    ras/rasnet.cc
    # === @end: ./ras (`@/src/ras/CMakeLists.txt`) ===


    # === @begin: ./nccl_device/ (`@/src/nccl_device/CMakeLists.txt`, `SYM_SOURCES`) ===
    nccl_device/core.cc
    nccl_device/ll_a2a.cc
    nccl_device/lsa_barrier.cc
    nccl_device/gin_barrier.cc
    # === @end: ./nccl_device/ (`@/src/nccl_device/CMakeLists.txt`, `SYM_SOURCES`) ===


    # === @begin: ./scheduler/ (`@/src/scheduler/CMakeLists.txt`) ===
    scheduler/allgatherv_sched.cc
    scheduler/symmetric_sched.cc
    # === @end: ./scheduler/ (`@/src/scheduler/CMakeLists.txt`) ===


    # === @begin: ./gin/ (`@/src/gin/CMakeLists.txt`) ===
    gin/gin_host.cc
    gin/gin_host_proxy.cc
    # === @end: ./gin/ (`@/src/gin/CMakeLists.txt`) ===


    # === @begin: ./os/ (`@/src/os/CMakeLists.txt`) ===
    os/linux.cc
    # os/windows.cc  # Not compiled on Linux
    # === @end: ./os/ (`@/src/os/CMakeLists.txt`) ===


    # === @begin: ./rma/ (`@/src/rma/CMakeLists.txt`) ===
    rma/rma.cc
    rma/rma_ce.cc
    rma/rma_proxy.cc
    # === @end: ./rma/ (`@/src/rma/CMakeLists.txt`) ===
)

add_library(nccl SHARED ${NCCL_SRC_FILES})

# Ensure git_version.h is generated before compiling
add_dependencies(nccl generate_git_version)

target_compile_definitions(
    nccl
    PUBLIC
        ${NCCL_COMMON_COMPILE_DEFINITIONS}
)


# @NVIDIA_ORIGINAL: @begin:
# @EUGO_CHANGE:
# We preserved this snippet as they rely on `CUDA_MAJOR` and `CUDA_MINOR` definitions in their code.
# To avoid collisions due to generic macro names used we renamed them into more standartized `CUDAToolkit_VERSION_MAJOR` and `CUDAToolkit_VERSION_MINOR`, respectively, set automatically by CMake after running `find_package(CUDAToolkit ...)`.
# We also mark them `PRIVATE` to avoid leakage to downstream packages if we'd need different treatment for these macros.
#
# Add CUDA version definitions after find_package
target_compile_definitions(
    nccl
    PRIVATE
        CUDAToolkit_VERSION_MAJOR=${CUDAToolkit_VERSION_MAJOR}
        CUDAToolkit_VERSION_MINOR=${CUDAToolkit_VERSION_MINOR}
)
# @NVIDIA_ORIGINAL: @end


# `WHOLE_ARCHIVE` is needed as `nccl_colldevice` is a static library and we want to get all its symbols!
target_link_libraries(nccl PRIVATE "$<LINK_LIBRARY:WHOLE_ARCHIVE,nccl_colldevice>")


# @Important:
# We couldn't use `NCCL_DEPENDENCIES` list here, as `cudart` is used in `nccl` interface while `cccl` is a header-only library only used as an implementation detail, so they must go into different section to avoid breaking downstream packages build failures or runtime UB!
target_link_libraries(
    nccl
    PRIVATE CCCL::libcudacxx
    INTERFACE CUDA::cudart
)


set_target_properties(
    nccl
    PROPERTIES
        VERSION ${NCCL_VERSION}
        SOVERSION ${NCCL_MAJOR}
        LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/lib"
)


# @EUGO_CHANGE: Version script controls symbol visibility — only nccl*/pnccl* are exported.
# Without this, all internal symbols leak into the .so's dynamic symbol table.
target_link_options(nccl PRIVATE
    "-Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/libnccl.map"
)


target_include_directories(
    nccl
    PUBLIC
        $<BUILD_INTERFACE:${CONFIGURED_HEADERS_DIR}>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/plugin>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
    PRIVATE
        # @EUGO_CHANGE: DOCA host headers (doca_gpunetio_host.h) needed by gin_host_gdaki.cc
        ${DOCA_HOME}/include
        ${DOCA_HOME}/include/host
)


# Only nccl.h and nccl_net.h are public headers and only they are installed!
set(NCCL_PUBLIC_HEADERS
    ${CONFIGURED_HEADERS_DIR}/nccl.h
    ${CMAKE_CURRENT_SOURCE_DIR}/include/plugin/nccl_net.h
    PARENT_SCOPE
)
# === @end: `libnccl` library ===


# === @begin: ras/ ===
add_subdirectory(ras)
# === @end: ras/ ===
